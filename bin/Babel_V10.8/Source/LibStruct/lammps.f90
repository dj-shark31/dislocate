MODULE lammps_module
  ! Structure file in lammps format as generated by the dump command 
  !   (native dump format)

  PRIVATE :: CutSentence

CONTAINS

  FUNCTION GetImmLammps(inp) RESULT(imm)
     ! Get maximal number of atoms imm from xyz file connected to unit inp
     
     IMPLICIT NONE
     INTEGER, intent(in) :: inp
     INTEGER :: imm

     CHARACTER(len=50) :: phrase
     INTEGER :: io

     imm=0

     ! Look for line "ITEM: NUMBER OF ATOMS"
     !   and read number of atoms in following line
     DO 
         READ(inp,'(a)', iostat=io) phrase
         IF (io.NE.0) THEN
                 WRITE(0,'(a)') 'Error when reading Lammps file'
                 WRITE(0,'(2a)') 'Last line read: ', phrase
                 STOP '< GetImmLammps >'
         END IF
         IF (Index(phrase,'ITEM:').NE.0) THEN
                 IF (Index(phrase,'NUMBER OF ATOMS').NE.0) THEN
                         READ(inp,*,iostat=io) imm
                         IF (io.NE.0) THEN
                                 WRITE(0,'(a)') 'Error when reading "number of atoms in Lammps file'
                                 WRITE(0,'(2a)') 'Last line read in Lammps file: ', phrase
                                 STOP '< GetImmLammps >'
                         END IF
                         EXIT
                 END IF
         END IF
         CYCLE
     END DO

     ! Check number of atoms
     IF (imm.LE.0) THEN
             WRITE(0,'(a,i0)') 'Number of atoms read in Lammps file: ', imm
             WRITE(0,'(a)') 'Line "ITEM: NUMBER OF ATOMS" should be missing in Lammps file'
             STOP '< GetImmLammps >'
     END IF

     REWIND(inp)

  END FUNCTION GetImmLammps

  SUBROUTINE ReadLammps(xp, iTyp, im, at, nTypes, inp)
     ! Read configuration in Lammps file connected to unit inp

     !USE Math
     IMPLICIT NONE
     REAL(kind(0.d0)), dimension(:,:), intent(out) ::xp
     INTEGER, dimension(:), intent(out) :: iTyp
     INTEGER, intent(out) :: im
     REAL(kind(0.d0)), dimension(1:3,1:3), intent(out) :: at
     INTEGER, intent(in) :: inp
     INTEGER, intent(out) :: nTypes

     REAL(kind(0.d0)), dimension(:,:), allocatable :: xc
     REAL(kind(0.d0)) :: xlo, xhi, ylo, yhi, zlo, zhi, &
             xlo_bound, xhi_bound, ylo_bound, yhi_bound, zlo_bound, zhi_bound, &
             xy, xz, yz
     CHARACTER(len=100) :: phrase, word
     INTEGER :: io, nProp
     LOGICAL :: im_read, at_read, id_read, type_read, &
             xu_read, xsu_read, x_read, xs_read, &
             yu_read, ysu_read, y_read, ys_read, &
             zu_read, zsu_read, z_read, zs_read
     INTEGER :: id_n, type_n, xu_n, xsu_n, x_n, xs_n, &
             yu_n, ysu_n, y_n, ys_n, zu_n, zsu_n, z_n, zs_n
     REAL(kind(0.d0)), dimension(:), allocatable :: aux
     INTEGER :: id, i
     REAL(kind(0.d0)), dimension(1:3) :: xs



     ! Default values
     im=0           ! Number of atoms in simulation box
     at(1:3,1:3)=0.d0   ! Lattice vector coordinates

     ! Look for line "ITEM: NUMBER OF ATOMS"
     !   and line "ITEM: BOX BOUNDS
     im_read=.FALSE.
     at_read=.FALSE.
     DO 
         READ(inp,'(a)', iostat=io) phrase
         IF (io.NE.0) THEN
                 WRITE(0,'(a)') 'Error when reading Lammps file'
                 WRITE(0,'(2a)') 'Last line read: ', phrase
                 IF (im_read) THEN
                         WRITE(0,'(a,i0)') 'Number of atoms read in Lammps file: ', im
                 ELSE
                         WRITE(0,'(a)') 'Number of atoms could not be read' 
                 END IF
                 IF (at_read) THEN
                         WRITE(0,'(a)') 'Periodicity vectors read in Lammps file:'
                         WRITE(0,'(a,3g20.12)') '    at(1:3,1): ', at(1:3,1)
                         WRITE(0,'(a,3g20.12)') '    at(1:3,2): ', at(1:3,2)
                         WRITE(0,'(a,3g20.12)') '    at(1:3,3): ', at(1:3,3)
                 ELSE
                         WRITE(0,'(a)') 'Periodicity vectors could not be read'
                 END IF
                 STOP '< ReadLammps >'
         END IF

         IF (Index(phrase,'ITEM:').NE.0) THEN

                 ! Number of atoms
                 IF (Index(phrase,'NUMBER OF ATOMS').NE.0) THEN
                         READ(inp,*,iostat=io) im
                         IF (io.NE.0) THEN
                                 WRITE(0,'(a)') 'Error when reading number of atoms in Lammps file'
                                 WRITE(0,'(2a)') 'Last line read: ', phrase
                                 STOP '< ReadLammps >'
                         END IF
                         im_read=.true.
                 END IF

                 ! Periodicity vectors
                 IF (Index(phrase,'BOX BOUNDS').NE.0) THEN

                         IF (Index(phrase,'xy xz yz').NE.0) THEN
                                 ! Triclinic cell
                                 READ(inp,*) xlo_bound, xhi_bound, xy
                                 READ(inp,*) ylo_bound, yhi_bound, xz
                                 READ(inp,*) zlo_bound, zhi_bound, yz
                                 xlo = xlo_bound - MIN(0.0,xy,xz,xy+xz)
                                 xhi = xhi_bound - MAX(0.0,xy,xz,xy+xz)
                                 ylo = ylo_bound - MIN(0.0,yz)
                                 yhi = yhi_bound - MAX(0.0,yz)
                                 zlo = zlo_bound
                                 zhi = zhi_bound
                                 at(1,1) = xhi - xlo ; at(2,1) = 0.d0      ; at(3,1) = 0.d0
                                 at(1,2) = xy        ; at(2,2) = yhi - ylo ; at(3,2) = 0.d0
                                 at(1,3) = xz        ; at(2,3) = yz        ; at(3,3) = zhi - zlo

                         ELSE
                         !ELSEIF (Index(phrase,'xx yy zz').NE.0) THEN
                                 ! Orthorombic cell
                                 READ(inp,*) xlo, xhi
                                 READ(inp,*) ylo, yhi
                                 READ(inp,*) zlo, zhi
                                 at(:,:) = 0.d0
                                 at(1,1) = xhi - xlo
                                 at(2,2) = yhi - ylo
                                 at(3,3) = zhi - zlo
                         !ELSE
                                 !! Unknown
                                 !WRITE(0,'(a)')  'Error when reading box definition in Lammps file'
                                 !WRITE(0,'(2a)') 'Last line read: ', phrase
                                 !STOP '< ReadLammps >'
                         END IF
                         at_read=.TRUE.
                 END IF
         END IF

         IF (im_read.AND.at_read) EXIT
         CYCLE
     END DO

     ! Check number of atoms
     IF (im.LE.0) THEN
             WRITE(0,'(a,i0)') 'Number of atoms read in Lammps file: ', im
             WRITE(0,'(a)') 'Line "ITEM: NUMBER OF ATOMS" should be missing in Lammps file'
             STOP '< ReadLammps >'
     END IF

     ! Maximal number of atoms in simulation box (used to allocate tables)
     IF ( (im.GT.size(xp,2)).OR.(im.GT.size(iTyp,1)) ) THEN
             WRITE(0,'(a,i0)') '  dimension of xp(1:3,:): ', size(xp,2)
             WRITE(0,'(a,i0)') '  dimension of iTyp(:): ', size(iTyp,1)
             WRITE(0,'(a,i0)') '  number of atoms read in Lammps file: ', im
             STOP '< ReadLammps >'
     END IF

     REWIND(inp)
     DO 
         READ(inp,'(a)', iostat=io) phrase
         IF (io.NE.0) THEN
                 WRITE(0,'(a)') 'Error when reading Lammps file'
                 WRITE(0,'(2a)') 'Last line read: ', phrase
                 STOP '< ReadLammps >'
         END IF

         CALL CutSentence(phrase,word)
         IF (TRIM(word).EQ.'ITEM:') THEN

                 CALL CutSentence(phrase,word)

                 IF (TRIM(word).EQ.'ATOMS') THEN
                         ! Reading atomic position
                         nProp = 0
     
                         id_read  =.FALSE.  ; id_n  =-1
                         type_read=.FALSE.  ; type_n=-1
                         xu_read  =.FALSE.  ; xu_n  =-1
                         xsu_read =.FALSE.  ; xsu_n =-1
                         x_read   =.FALSE.  ; x_n   =-1
                         xs_read  =.FALSE.  ; xs_n  =-1
                         yu_read  =.FALSE.  ; yu_n  =-1
                         ysu_read =.FALSE.  ; ysu_n =-1
                         y_read   =.FALSE.  ; y_n   =-1
                         ys_read  =.FALSE.  ; ys_n  =-1
                         zu_read  =.FALSE.  ; zu_n  =-1
                         zsu_read =.FALSE.  ; zsu_n =-1
                         z_read   =.FALSE.  ; z_n   =-1
                         zs_read  =.FALSE.  ; zs_n  =-1
                         DO WHILE (len_trim(phrase).GT.0)
                            nProp = nProp+1
                            CALL CutSentence(phrase,word)
                            SELECT CASE(word)
                            CASE('id')
                                    id_read = .TRUE.
                                    id_n = nProp
                            CASE('type')
                                    type_read = .TRUE.
                                    type_n = nProp
                            CASE('xu')
                                    xu_read = .TRUE.
                                    xu_n = nProp
                            CASE('xsu')
                                    xsu_read = .TRUE.
                                    xsu_n = nProp
                            CASE('x')
                                    x_read = .TRUE.
                                    x_n = nProp
                            CASE('xs')
                                    xs_read = .TRUE.
                                    xs_n = nProp
                            CASE('yu')
                                    yu_read = .TRUE.
                                    yu_n = nProp
                            CASE('ysu')
                                    ysu_read = .TRUE.
                                    ysu_n = nProp
                            CASE('y')
                                    y_read = .TRUE.
                                    y_n = nProp
                            CASE('ys')
                                    ys_read = .TRUE.
                                    ys_n = nProp
                            CASE('zu')
                                    zu_read = .TRUE.
                                    zu_n = nProp
                            CASE('zsu')
                                    zsu_read = .TRUE.
                                    zsu_n = nProp
                            CASE('z')
                                    z_read = .TRUE.
                                    z_n = nProp
                            CASE('zs')
                                    zs_read = .TRUE.
                                    zs_n = nProp
                            END SELECT
                         END DO
                         IF ( (.NOT.(xu_read.OR.xsu_read.OR.x_read.OR.xs_read)) &
                                .OR. (.NOT.(yu_read.OR.ysu_read.OR.y_read.OR.ys_read)) &
                                .OR. (.NOT.(zu_read.OR.zsu_read.OR.z_read.OR.zs_read)) ) THEN
                                 WRITE(0,'(a)') 'X, y or z position not defined in Lammps file'
                                 backspace(inp)
                                 READ(inp,*) phrase
                                 WRITE(0,'(2a)') 'Last line read: ', phrase
                                 STOP '< ReadLammps >'
                         END IF


                         ALLOCATE(aux(1:nProp))
                         loop_atoms: DO i=1, im
                             READ(inp,*, iostat=io) aux(1:nProp)
                             IF (io.NE.0) THEN
                                     WRITE(0,'(a,i0,a)') 'Error when reading definition for atom ', i,' in Lammps file'
                                     STOP '< ReadLammps >'
                             END IF

                             ! Atom id
                             IF (id_read) THEN
                                     id = Int( aux(id_n) )
                             ELSE
                                     id = i
                             END IF

                             ! Atom type
                             IF (type_read) THEN
                                     iTyp(id) = Int( aux(type_n) )
                             ELSE
                                     iTyp(id) = 1
                             END IF

                             ! Atom x position
                             IF (xu_read) THEN
                                     xp(1,id) = aux(xu_n)
                             ELSEIF (xsu_read) THEN
                                     xs(1) = aux(xsu_n)
                             ELSEIF (x_read) THEN
                                     xp(1,id)  = aux(x_n)
                             ELSEIF (xs_read) THEN
                                     xs(1) = aux(xs_n)
                             END IF

                             ! Atom y position
                             IF (yu_read) THEN
                                     xp(2,id) = aux(yu_n)
                             ELSEIF (ysu_read) THEN
                                     xs(2) = aux(ysu_n)
                             ELSEIF (y_read) THEN
                                     xp(2,id)  = aux(y_n)
                             ELSEIF (ys_read) THEN
                                     xs(2) = aux(ys_n)
                             END IF

                             ! Atom z position
                             IF (zu_read) THEN
                                     xp(3,id) = aux(zu_n)
                             ELSEIF (zsu_read) THEN
                                     xs(3) = aux(zsu_n)
                             ELSEIF (z_read) THEN
                                     xp(3,id)  = aux(z_n)
                             ELSEIF (zs_read) THEN
                                     xs(3) = aux(zs_n)
                             END IF

                             ! Transform reduced coordinates in cartesian
                             ! coordinates if cartesian coordinates have not
                             ! been already defined
                             IF ( ( xsu_read.AND.(.NOT.xu_read) ) .OR. &
                                     ( xs_read.AND.(.NOT.(xu_read.OR.x_read)) ) ) THEN
                                     xp(1:3,id) = MatMul( at(1:3,1:3), xs(1:3) )
                             END IF
                                       
                         END DO loop_atoms
                         DEALLOCATE(aux)
                         EXIT

                 END IF
         END IF
     END DO

     nTypes=MaxVal( iTyp(1:im) )

  END SUBROUTINE ReadLammps

  SUBROUTINE WriteLammps(xp, iTyp, im, at, out, &
        mask, nAux_int, aux_int, nAux_real, aux_real, aux_title)
     ! Write structure in output file connected to unit out using Lammps (dump) format
     !  If mask is given, only atoms for which mask(i)=.TRUE. are written
     !  Additional columns are used to print auxiliary properties
     !   nAux_int, nAux_real: number of auxiliary properties to print (int and real types)
     !   aux_int(1:nAux_int), aux_real(1:nAux_real): corresponding property for atom i
     !   aux_title(1:nAux_int): title for auxiliary property with integer type
     !   aux_title(nAux_int+1:nAux_int+nAux_real): title for auxiliary property with real type

     USE mathStruct
     IMPLICIT NONE
     REAL(kind(0.d0)), dimension(:,:), intent(in) ::xp
     INTEGER, dimension(:), intent(in) :: iTyp
     INTEGER, intent(in) :: im
     REAL(kind(0.d0)), dimension(1:3,1:3), intent(in) :: at
     INTEGER, intent(in) :: out
     LOGICAL, dimension(:), intent(in), optional :: mask
     INTEGER, intent(in), optional :: nAux_int, nAux_real
     INTEGER, dimension(:,:), optional :: aux_int
     REAL(kind(0.d0)), dimension(:,:), optional :: aux_real
     CHARACTER(len=50), dimension(:), intent(in), optional :: aux_title

     LOGICAL, dimension(:), allocatable :: local_mask
     LOGICAL :: test_aux_int, test_aux_real
     REAL(kind(0.d0)) :: ax, bx, by, cx, cy, cz
     REAL(kind(0.d0)) :: xlo, xhi, ylo, yhi, zlo, zhi, &
             xlo_bound, xhi_bound, ylo_bound, yhi_bound, zlo_bound, zhi_bound, &
             xy, xz, yz
     REAL(kind(0.d0)), dimension(:,:), allocatable :: xc
     REAL(kind(0.d0)), dimension(1:3,1:3) :: inv_at
     INTEGER :: i
     CHARACTER(len=50) :: out_format



     ! Test input parameters
     IF (Allocated(local_mask)) Deallocate(local_mask)
     Allocate(local_mask(1:im))
     IF (Present(mask)) THEN
             local_mask(1:im)=mask(1:im)
     ELSE
             local_mask = .TRUE.
     END IF
     IF ( Present(nAux_int) ) THEN
             IF ( (.NOT.Present(aux_int)) .OR. (.NOT.Present(aux_title)) ) THEN
                     WRITE(0,'(a)') 'All auxiliary properties have to be defined'
                     STOP '< WriteXyz >'
             END IF
             IF (Size(aux_int,1).LT.nAux_int)  THEN
                     WRITE(0,'(a)') 'Problem with size of auxiliary properties'
                     STOP '< WriteXyz >'
             END IF
             test_aux_int=.TRUE.
     ELSE
             test_aux_int=.FALSE.
     END IF
     IF ( Present(nAux_real) ) THEN
             IF ( (.NOT.Present(aux_real)) .OR. (.NOT.Present(aux_title)) ) THEN
                     WRITE(0,'(a)') 'All auxiliary properties have to be defined'
                     STOP '< WriteXyz >'
             END IF
             IF (Size(aux_real,1).LT.nAux_real)  THEN
                     WRITE(0,'(a)') 'Problem with size of auxiliary properties'
                     STOP '< WriteXyz >'
             END IF
             test_aux_real=.TRUE.
     ELSE
             test_aux_real=.FALSE.
     END IF

     ! -- Header --
     WRITE(out,'(a)') "ITEM: TIMESTEP"
     WRITE(out,'(i0)') 0
     WRITE(out,'(a)') "ITEM: NUMBER OF ATOMS"
     WRITE(out,'(i0)') Count(local_mask(1:im))        ! Number of atoms

     ! -- Periodicity vectors in Lammps style for triclinic box --
     !   http://lammps.sandia.gov/doc/Section_howto.html#triclinic-non-orthogonal-simulation-boxes
     ax = Sqrt( Sum( at(1:3,1)**2 ) )
     bx = Sum( at(1:3,2)*at(1:3,1) )/ax
     by = Sqrt( Sum( at(1:3,2)**2 ) - bx**2 )
     cx = Sum( at(1:3,3)*at(1:3,1) )/ax
     cy = ( Sum( at(1:3,2)*at(1:3,3) ) - bx*cx )/by
     cz = Sqrt( Sum( at(1:3,3)**2 ) - cx**2 - cy**2 )

     ! Put box origin on a corner atom
     xlo = MinVal( xp(1,1:im) )
     ylo = MinVal( xp(2,1:im) )
     zlo = MinVal( xp(3,1:im) )
     xlo = 0.d0
     ylo = 0.d0
     zlo = 0.d0

     xhi = xlo + ax
     yhi = ylo + by
     zhi = zlo + cz
     xy = bx
     xz = cx
     yz = cy

     xlo_bound = xlo + MIN(0.0,xy,xz,xy+xz)
     xhi_bound = xhi + MAX(0.0,xy,xz,xy+xz)
     ylo_bound = ylo + MIN(0.0,yz)
     yhi_bound = yhi + MAX(0.0,yz)
     zlo_bound = zlo
     zhi_bound = zhi

     WRITE(out,'(a)') "ITEM: BOX BOUNDS xy xz yz"
     WRITE(out,'(3(g24.16,1x))') xlo_bound, xhi_bound, xy
     WRITE(out,'(3(g24.16,1x))') ylo_bound, yhi_bound, xz
     WRITE(out,'(3(g24.16,1x))') zlo_bound, zhi_bound, yz


     ! -- Atom positions in reduced coordinates --
     !   this is necessary because the periodicity vectors may have been rotated
     CALL Mat3Inv(at,inv_at)
     ALLOCATE(xc(1:3,1:im))
     xc(1:3,1:im) = MatMul( inv_at(1:3,1:3), xp(1:3,1:im) )
     IF (test_aux_int.AND.test_aux_real) THEN
             WRITE(out_format,'(a,i0,a)') '(a,', nAux_int+nAux_real,'(" ",a))'
             WRITE(out,out_format) 'ITEM: ATOMS id type xsu ysu zsu', &
                 (Trim(AdjustL(aux_title(i))),i=1,nAux_int+nAux_real) ! Title
             WRITE(out_format,'(a,3(i0,a))') &
                 '(2(i0,1x),',3,'(g24.16,1x),',nAux_int,'(i0,1x)',nAux_real,'(1x,g24.16))'
             DO i=1, im
                IF (local_mask(i)) WRITE(out,out_format) i, iTyp(i), xc(1:3,i), &
                         aux_int(1:nAux_int,i),  aux_real(1:nAux_real,i)
             END DO
     ELSEIF (test_aux_int) THEN
             WRITE(out_format,'(a,i0,a)') '(a,', nAux_int,'(" ",a))'
             WRITE(out,out_format) 'ITEM: ATOMS id type xsu ysu zsu', &
                 (Trim(AdjustL(aux_title(i))),i=1,nAux_int) ! Title
             WRITE(out_format,'(a,2(i0,a))') &
                 '(2(i0,1x),',3,'(g24.16,1x),',nAux_int,'(i0,1x))'
             DO i=1, im
                IF (local_mask(i)) WRITE(out,out_format) i, iTyp(i), xc(1:3,i), &
                         aux_int(1:nAux_int,i)
             END DO
     ELSEIF (test_aux_real) THEN
             WRITE(out_format,'(a,i0,a)') '(a,', nAux_real,'(" ",a))'
             WRITE(out,out_format) 'ITEM: ATOMS id type xsu ysu zsu', &
                 (Trim(AdjustL(aux_title(i))),i=1,nAux_real) ! Title
             WRITE(out_format,'(a,i0,a)') '(2(i0,1x),',3+nAux_real,'(g24.16,1x))'
             DO i=1, im
                IF (local_mask(i)) WRITE(out,out_format) i, iTyp(i), xc(1:3,i), &
                         aux_real(1:nAux_real,i)
             END DO
     ELSE
             WRITE(out,'(a)') 'ITEM: ATOMS id type xsu ysu zsu'                ! Title
             WRITE(out_format,'(a,i0,a)') '(2(i0,1x),',3,'(g24.16,1x))'
             DO i=1, im
                IF (local_mask(i)) WRITE(out,out_format) i, iTyp(i), xc(1:3,i)
             END DO
     END IF

    Deallocate(local_mask, xc)


  END SUBROUTINE WriteLammps

  SUBROUTINE CutSentence(phrase, word)
     ! word is the first word of phrase
     ! on output, word has been deleted from phrase

     IMPLICIT NONE
     CHARACTER(len=*), intent(inout) :: phrase
     CHARACTER(len=*), intent(out)   :: word
 
     INTEGER :: pos

     IF (len_trim(phrase).EQ.0) THEN
             phrase=''
             word=''
             RETURN
     END IF

     phrase = Adjustl(phrase)
     pos = Index(phrase,' ')
     word = phrase(1:pos-1)
     phrase = Adjustl(phrase(pos+1:))

  END SUBROUTINE CutSentence


END MODULE lammps_module
