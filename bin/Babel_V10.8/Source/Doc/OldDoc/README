
Compilation:
===========
See the makefile.

Programs:
========
babel: create line defects using anisotropic elasticiy.
displacement: calculate atom displacements between 2 configuration files
vitek: calculate Vitek displacement map using output of the program displacement (xyz format). 
	This works for screw components along the z axis. 
	For structure other than the bcc one with xy plane being of (111) type, 
	you need to customize the cutoff radius for 1st nearest neighbours search.

Execution:
=========
babel input.dat
displacement input.dat
where input.dat is the input file
If input.dat="-", the input is read from current unit (keyboard or piped other command like echo)

Input file for Babel:
====================

dislo=.true. for creating a dislocation
You need then to define nd, the number of dislocation
For each dislocation i
	- the line vector lDislo(1:3,i) (arbitrary units)
	- the Burgers vector bDislo(1:3,i) (A)
	- a point cDislo(1:3,i) where the dislo goes through (A)
	- optional: cutDislo(1:3,i) defining with lDislo the cutting half-plane 
	where a displacement discontinuity occurs (arbitrary units)
	This cut-line is important when periodic boundary conditions are used:
	as this is a little bit tricky, you better let the program set this variable.
alat is used to scale bDislo and cDislo 
The SF/RH convention is enforced

remove_cut=.true.: use this option to remove atoms when creating the cut associated
with the creation of the dislocation or the dislocation dipole (Volterra process). 
As the program only knows how to remove atoms and not how to add atoms, this only
works if your dipole is of vacancy type and not of interstitial type. 
If you are using periodic boundary conditions, you can always choose dislocation
positions so as to have V dipole (just add one periodicity vector to the location 
of one of the two dislocations to go from an I to a V dipole).


----------
LineForce=.true. for creating a line-force 
nlf: number of line-forces
For each line-force i
	- lLineForce(1:3,i): line vector (arbitrary units)
	- fLineForce(1:3,i): force per unit length (GPa.A)
	- cLineForce(1:3,i): a point where the line-force goes through (A)
	- optional: cutLineForce(1:3,i) defining with lLineForce the cutting half-plane 
	where a discontinuity of the stress primitive occurs (arbitrary units)
alat is used to scale cLineForce.

----------
LineCouple=.true. for creating a line-force couple
nlc: number of line-force couples
For each LineCouple i
	- lLineCouple(1:3,i): line vector (arbitrary units)
	- mxLineCouple(i) and myLineCouple(i): force moments in x and y directions (GPa.A^2)
	- xLineCouple(1:3,i) and yLineCouple(1:3,i): corresponding directions (at least one have to be defined)
	- cLineCouple(1:3,i): a point where the line-force couple goes through (A)
alat is used to scale cLineCouple.

----------
If initial=.true., the initial coordinates are kept for the output file.
Otherwise, the displacement field due to the dislocations and the line-force couples
is added to the atom coordinates (default value=.false.)

xImages (yImages, zImages): if .TRUE., periodic boundary 
conditions are assumed in the corresponding direction and images
are considered. The number of images is given by nxImages
(nyImages, nzImages). The default value is 10: you need to check
in the output that stresses are converged for this value. 
For a small unit-cell like the ones used in ab-initio calculation,
you probably need to increase this value to 100.
Another way to check convergency is to run several simulations. As the point where periodicity is enforced
is randomly chosen, different simulations will lead to different results for elastic energy. Nevertheless, 
differences should be small (less than 0.1 meV) and correspond to calculation convergency.

fixGravity: if .TRUE. a solid displacement is added after creating line defects
so as to keep fixed gravity center

clipAtom: if .TRUE., periodic boundary conditions are applied to atom coordinates.

at(1:3,1), at(1:3,2), at(1:3,3): 3 periodicity vectors (optional)
The program tries first to read them in the input file and then 
in the input structure file. If vectors are defined in both files, 
the ones defined in the input structure file will be used.
You have to defined these vectors if you want to:
	- duplicate the unit cell
	- apply periodic boundary conditions
	- write the output structure file in cfg format.
	
----------
For creating a dislocation, a line-force or a line-force couple, 
elastic constants have to be given.
cubic_elasticity=.true.: crystal with cubic symmetry. 
  You need then to give the three constants C11, C12, and C44.
  Make sure the crystal is oriented in the cubic
  axes corresponding to the elastic constants.
hexagonal_elasticity=.true.: crystal with hexagonal symmetry.
  You need then to give the five constants C11, C12, C13, C33 and C44.
  C66=(C11-C12)/2 is automatically calculated.
  Make sure the crystal is oriented so that the z coordinate corresponds
  to the 6-fold symmetry axis.
anisotropic_elasticity=.true.: crystal with any symmetry (or any orientation)
  You need to give the elasticity matrix CVoigt(:,:) (only non-null elements)
The program cannot handle exactly isotropic elasticity due to a numeric instability
(degeneracy of the roots of the sextic equation).
The degeneracy may be lift by adding some noise to the elastic constants. 
CVoigt_noise=x will add a random noise of maximal amplitude x to all elastic constants.

rc: cutoff radius corresponding to the core of the line defects.
This is usefull for energy calculations and to define atoms inside the core (see out_core)

----------
rotate=.true. for rotating the crystal 
rot(1:3,1:3) is the rotation matrix.
The program also rotates the vector defining the point and linear defects
and the matrix defining the elastic constants.

----------
duplicate=.true. for duplicating the crystal
lat(1:3) is the number of times the crystal should be duplicated
in each direction given by the vectors at(1:3,i) read in the structure file.
If lat(i) is negative, then the opposite of the vector at(1:3,i) is used.
If you create a dislocation, the crystal will be duplicated first
and then the dislocation created.

----------
slab=.true. for extracting a slab from unit cell
nxSlab, nySlab, and nzSlab are the number of slabs to be considered 
for each periodicity vectors

----------
translate=.true. for translating the crystal
uTranslate(1:3) is the translation vector.
If alat is defined, uTranslate(1:3) is multiplied by alat.
The program also translates the points defining the line-defect centers.

----------
strain=.true. to apply homogeneous strain to the crystal
eStrain(1:3,1:3): strain to apply
sStrain(1:3,1:3): equivalent "stress" from which the applied strain is calculated
	Beware: this is not really the stress. The real stress should be C.(e-e0)
		where e0 is the free strain but is not known a priori. 
		The array sStrain(:,:) corresponds to C.e

induced_homogeneous_strain:  If true, the homogeneous strain induced by line-defects
	is included (default value = .true.).
----------
imm: maximal number of atoms

----------
impurity=.true. the program will calculate the elastic interaction 
between an impurity characterized by its dipole elastic tensor pImpurity (1:3,1:3)
and the strain field (Eshelby theory).
The resulting energy will be printed if out_Ebinding=.true.
Energies are in the same unit as pImpurity (normally in eV)

----------
inpXyz, inpCfg, inpGin, inpLisa, inpSiesta, outXyz, outCfg, outGin, outLisa, outSiesta = .true. if the input or output
structure files are in xyz, cfg, gin, Lisa, or Siesta format.
inpFile, outFile: names of the input and output structure files.
If outFile="-", the output structure is written on screen.
If inpFile="-", the input is read from keyboard.

out_alat: for xyz and cfg structure file formats, atomic positions 
	and periodicity vectors can be scaled by a lattice parameter
	given in out_alat

nTypes: number of different atom types
label(:): label corresponding to each atom type
mass(:): mass corresponding to each atom type

out_displacement: print the displacement vector on output if true.
out_stress: print the 6 components of the stress tensor if true
out_elasticStrain: print the 6 components of the strain tensor if true
out_pressure: print the pressure on output if true.
out_VonMises: print the Von-Misès equivalent shear stress on output if true.
out_core: print index 1 for atom belonging to core, ie closer than rc
	from a line defect.

----------
verbosity: integer value between 0 and 10 controlling outputs
  verbosity=0: no output
  verbosity=4: normal output (this is the standard value)
  verbosity=10: debugging

----------
Eulerian or Lagrangian coordinates can be used
In Lagrangian coordinates, elastic fields (displacement, stress) are calculated at point x0
corresponding to the initial coordinates.
In Eulerian coordinates, fields are calculated at point x = x0 + u(x),
where u(x) is the displacement calculated at the final point.
A self-consistency loop is used for Eulerian coordinates. This loop is controlled by:
max_Euler: maximal number of iterations in the loop
	default value is max_Euler=0 and corresponds to Lagrangian coordinates
delta_Euler: absolute convergency for the displacement. The self-consistency loop
	stops when u(x) is smaller than (x-x0) (in absolute value).

Units:
=====
Stress units are controlled by the units you used for elastic constants (GPa for instance).
Distance units need to be consistent between input and structure files 
(use A everywhere for instance).
Force units for line force are given by [stress]*[distance].
Moment units for line-force couples are given by [stress]*[distance]^2.
If you used GPa and A, force units have to be [GPa]*[A] = 0.1 N/m
and moment units have to be [GPa]*[A]^2 = 1e-11 N.


Input file for Displacement:
===========================

inpXyz, inpCfg, inpGin, inpLisa, inpSiesta, inpFile: definition of input file (final positions)
refXyz, refCfg, refGin, refLisa, refSiesta, refFile: definition of reference file (initial positions)
If inpFile="-" and refFile="-", the program read first the input file and then the reference
	file from keyboard.
outXyz, outCfg, outFile: definition of output file containing atom position and displacements
initial: if .true.(.false.), initial (final) atom positions are used in output file, 
fixGravity: if .TRUE. a solid displacement is added to atom final positions and displacements
	to keep fixed gravity center
translate: if .TRUE. a solid displacement given by uTranslate(1:3) is added  to atom final positions
	and displacements
rotate: if .TRUE. a rotation given by rotation(1:3,1:3) is applied to atom positions and displacements.
duplicate: if .TRUE., the unit cells are duplicated lat(i) times in at(1:3,i) direction
clipDisplacement: if .TRUE. periodic boundary conditions are applied to atom displacements.
clipAtom: if .TRUE., periodic boundary conditions are applied to atom coordinates to bring them back in the primitive unit cell.


Structure files:
===============

They can be given in:
	- xyz format (compatible with rasmol, glmol, gnuplot)
	- cfg format (compatible with atomeye)
	- gin format (compatible with NDM90)
Right now, the program assumes there is only one atom type (no alloy) for cfg format.


Xyz format:
==========
line 1: is the number of atoms.
line 2: title (on output, short description of each column)
following line: for each atom, the atom type followed by its Cartesian 
  coordinates. On output, there can be some optional columns given auxiliary properties
  like the displacement vector ux, uy, uz, the pressure and the Von-Misès equivalent
  shear stress.
a blank line
3 (optional) lines giving the periodicity vectors
  at(1:3,1)
  at(1:3,2)
  at(1:3,3)
a blank line
1 (optional) line giving a scaling factor for the atom coordinates
  and the periodicity vector
The lines defining the periodicity vectors are needed if you want 
to duplicate the unit cell or if you want to write the output structure 
in cfg format.


Cfg format:
==========
Extended cfg format.
See atomeye documentation.


Lisa format:
=============
This is the format used by Lisa in her calculations with Siesta
line 1: lattice parameter
line 2: periodicity vector at(1:3,1)
line 3: periodicity vector at(1:3,2)
line 4: periodicity vector at(1:3,3)
lines 5-...: 1 line per atom with for each atom: x, y, z, i, label
	i is an integer defining the atom type
	label is the symbol corresponding to this atom type
All lines are mandatory. The periodicity vectors and the atom coordinates
are multiplied by the lattice parameter (use 1. as lattice parameter if you 
do not want any scaling).


Siesta format:
=============
This corresponds to the files *.STRUCT_IN and *.STRUCT_OUT read 
and written by Siesta
	

Default values for input parameters:
===================================

    out_alat=1.d0
    rc=1.d0
    initial=.FALSE.
    dislo=.FALSE.
    nd=0
    lDislo(1:3,:) = 0.d0 
    bDislo(1:3,:) = 0.d0 
    cDislo(1:3,:) = 0.d0
    cutDislo(1:3,:) = 0.d0
    alat = 1.d0
    LineForce=.FALSE.
    nlf=0
    lLineForce(1:3,:) = 0.d0
    fLineForce(1:3,:) = 0.d0
    cLineForce(1:3,:) = 0.d0
    cutLineForce(1:3,:) = 0.d0
    LineCouple=.FALSE.
    nlc=0
    lLineCouple(1:3,:) = 0.d0
    mxLineCouple(:) = 0.d0
    xLineCouple(1:3,:) = 0.d0
    myLineCouple(:) = 0.d0
    yLineCouple(1:3,:) = 0.d0
    cLineCouple(1:3,:) = 0.d0
    strain=.FALSE.
    eStrain(1:3,1:3) = 0.d0
    induced_homogeneous_strain=.true.
    fixGravity=.FALSE.
    translate=.FALSE.
    uTranslate(1:3) = 0.d0
    xImages=.FALSE.
    yImages=.FALSE.
    zImages=.FALSE.
    nxImages=10
    nyImages=10
    nzImages=10
    clipDisplacement=.FALSE.
    clipAtom=.FALSE.
    cubic_elasticity=.FALSE. 
    hexagonal_elasticity=.FALSE.
    anisotropic_elasticity=.FALSE. 
    Impurity=.FALSE.
    pImpurity(1:3,1:3) = 0.d0
    factorE=1.d9*1.d-30/1.602176530000000045d-19        ! GPa.A^3 => eV
    C11 = 0.d0 
    C12 = 0.d0
    C13 = 0.d0
    C33 = 0.d0
    C44 = 0.d0
    CVoigt(:,:)=0.d0
    inv_CVoigt(:,:)=0.d0
    CVoigt_noise=0.d0
    out_pressure=.FALSE.
    out_VonMises=.FALSE.
    out_stress=.FALSE.
    out_elasticStrain=.FALSE.
    out_displacement=.FALSE.
    out_Ebinding=.FALSE.
    at(1:3,1:3)=0.d0
    inpXyz=.FALSE. ; inpCfg=.FALSE. ; inpGin=.FALSE. ; inpLisa=.FALSE. ; inpSiesta=.FALSE. 
    outXyz=.FALSE. ; outCfg=.FALSE. ; outGin=.FALSE. ; outLisa=.FALSE. ; outSiesta=.FALSE.
    refXyz=.FALSE. ; refCfg=.FALSE. ; refGin=.FALSE. ; refLisa=.FALSE. ; refSiesta=.FALSE. 
    inpFile='-' ; outFile='-' ; refFile='-'
    imm=0
    duplicate=.FALSE.
    lat(1:3)=1
    rotate=.FALSE.
    rot(1:3,1:3)=matId(1:3,1:3) ! Identity matrix
    tStep=0.d0
    nCalc=1
    max_Euler=0 ! default = Lagrangian coordinates
    delta_Euler=1.d-5
    verbosity=4
    nTypes=0
    mass(1:max_nTypes)=0.d0
    DO i=1, max_nTypes
       label(i)=aChar(i+64)
    END DO
    
===========================================


