<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="input_xx.xsl" type="text/xsl"?>
<manual>
	<title>
		Program patternDetect
	</title>
	<intro> 
		This program finds the different crystallographic patterns
		in a reference structure file and writes them in an output file. 
		This output file can then be used with the program <a href="input_displacement.xml">displacement</a>
		to define the reference crystallographic patterns, 
		so as to extract the elastic strain, the Nye tensor,
		or the dislocation densities from a strained structure.

		A crystallographic pattern corresponds to the number of neighbours 
		of an atom (inside a sphere defined by a cutoff radius)
		and to the positions of these neighbours.
		Perfect BCC and FCC structures have only one pattern,
		whereas perfect HCP structure has two patterns.

		Execution:
		=========
		patternDetect input.dat
		where input.dat is the input file
		If input.dat="-", the input is read from current unit (keyboard or piped other command like echo)


		Structure of the input file:
		===========================

		The input file contains only the namelist input

		&amp;input
		  ...
		//
	</intro>
	<namelist name="input">
		<name> input </name>
		<var name="refFile">
			<name>	refFile </name>
			<type> character string </type>
			<default> '-' </default>
			<mandatory> yes </mandatory>
			<info>
				Name of the structure file used as a reference.
				If refFile='-', the structure is read from keyboard.
				The file format is defined by refXyz | refCfg | refGin | refSiesta | refNDM | refLammps | refPoscar
			</info>
		</var>
		<var name="refXyz, refCfg, refGin, refSiesta, refNDM, refLammps, refPoscar">
			<name>	refXyz, refCfg, refGin, refSiesta, refNDM, refLammps, refPoscar  </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> one should be set to .true. </mandatory>
			<info>
				If refXyz=.true. the reference structure file 
				is given in xyz format.
			</info>
			<see_also> <elink> <text>Structure file formats</text> <url>./structures.html</url></elink> </see_also>
		</var>
		<var name="imm">
			<name>	imm </name>
			<type> integer </type>
			<default> 0 </default>
			<mandatory> no </mandatory>
			<info>
				Maximal number of atom in the structure.
				imm needs to be defined if the input structure is duplicated 
				to dimension the arrays. 
				Otherwise, the actual number of atoms, read from input structure file, is used.
			</info>
			<see_also> <ilink> duplicate </ilink> </see_also>
		</var>
		<var name="duplicate">
			<name> duplicate </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If duplicate=.true., the crystal is duplicated.
				lat(1:3) is the number of times the crystal should be duplicated
				in each direction given by the vectors at(1:3,i) read in the structure file.
				If lat(i) is negative, then the opposite of the vector at(1:3,i) is used.
				The maximal number of atoms in the duplicated structure needs to be set with imm
				and the periodicity vectors have to be defined.

				When the structure is also rotated, the duplication is done first and then the rotation.
				The periodicity vectors used for duplication are thus those before rotation.

				For small simulation boxes, it may be necessary to duplicate the structure 
				to find all neighbours of the atoms.
			</info>
			<see_also> <ilink> imm </ilink> </see_also>
			<see_also> <ilink> lat </ilink> </see_also>
		</var>
		<var name="lat">
			<name>	lat </name>
			<type> integer, dim(3) </type>
			<default> 1 </default>
			<mandatory> no  </mandatory>
			<info>
				Number of replicas in each direction when duplicating the input structure file.
			</info>
			<see_also> <ilink> duplicate </ilink> </see_also>
		</var>
		<var name="rotate">
			<name> rotate </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If rotate=.true., the crystal is rotated using rotation matrix defined in rot(1:3,1:3)
			</info>
			<see_also> <ilink> rot </ilink> </see_also>
		</var>
		<var name="rot">
			<name> rot </name>
			<type> real, dim(3,3) </type>
			<default> identity matrix </default>
			<mandatory> no </mandatory>
			<info>
				Rotation matrix used when rotate=.true.
			</info>
			<see_also> <ilink> rotate </ilink> </see_also>
		</var>
		<var name="translate">
			<name> translate </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If translate=.true., the crystal is translated with the vector uTranslate(1:3)
			</info>
			<see_also> <ilink> uTranslate </ilink> </see_also>
		</var>
		<var name="uTranslate">
			<name> uTranslate </name>
			<type> real, dim(3) </type>
			<default> 0. </default>
			<mandatory> no </mandatory>
			<info>
				Translation vector used when translate=.true.
				If alat is defined, uTranslate(1:3) is multiplied by alat.
			</info>
			<see_also> <ilink> translate </ilink> </see_also>
			<see_also> <ilink> alat </ilink> </see_also>
		</var>
		<var name="clipAtom">
			<name> clipAtom </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If clipAtom=.true., periodic boundary conditions are applied
			       	to atom coordinates to bring them back in the primitive unit cell.
				The periodicity vectors have to be defined.
			</info>
		</var>
		<var name="alat">
			<name> alat </name>
			<type> real </type>
			<default> 1. </default>
			<mandatory> no </mandatory>
			<info>
				Length used to scale all distances in the present input file.
				For program patternDetect, it only affects the quantities rNeigh and uTranslate(1:3).
			</info>
		</var>
		<var name="patternFile">
			<name> patternFile </name>
			<type> character string </type>
			<default> empty </default>
			<mandatory> no </mandatory>
			<info>
				If it is defined, the patterns found in the reference structure file
			       are saved in the file whose name is given by patternFile.
			       This file can then be read by program displacement.
			</info>
		</var>
		<var name="rNeigh">
			<name> rNeigh </name>
			<type> real </type>
			<default> -1. </default>
			<mandatory> yes </mandatory>
			<info>
				Distance cutoff defining the sphere where atom neighbours have to be looked for.
				If alat is defined, rNeigh is multiplied by alat.

			</info>
			<see_also> <ilink> alat </ilink> </see_also>
		</var>
		<var name="max_nNeigh">
			<name> max_nNeigh </name>
			<type> integer </type>
			<default> 16 </default>
			<mandatory> no </mandatory>
			<info>
				Maximal number of neighbours allowed for each atom.
			</info>
		</var>
		<var name="outFile">
			<name> outFile </name>
			<type> character string </type>
			<default> '-' </default>
			<mandatory> no </mandatory>
			<info>
				The reference structure can be saved back in file defined by outFile
				which auxiliary properties set for each atom (number of neighbours,
				atom pattern, ...)
				If outFile="-", the output file is printed on screen.
				The file format is defined by outXyz | outCfg  | outOnlyAtoms
			</info>
		</var>
		<var name="outXyz, outCfg, outOnlyAtoms, outLammps">
			<name> outXyz, outCfg, outOnlyAtoms, outLammps </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				Format of the structure file used for output.
				If all variables are set to .false. (default), the output structure
				is not written.
			</info>
			<see_also> <ilink> outFile </ilink> </see_also>
		</var>
		<var name="out_neighbours">
			<name> out_neighbours </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_neighbours=.true., the number of neighbours 
				is saved in output structure file for each atom.
			</info>
			<see_also> <ilink> outFile </ilink> </see_also>
		</var>
		<var name="out_pattern">
			<name> out_pattern </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_pattern=.true., the output pattern 
				is saved in output structure file for each atom.
			</info>
			<see_also> <ilink> outFile </ilink> </see_also>
		</var>
		<var name="verbosity">
			<name> verbosity </name>
			<type> integer </type>
			<default> 4 </default>
			<mandatory> no </mandatory>
			<info>
				Integer values defining amount of information on output unit.
				verbosity=0: no output
				verbosity=4: normal output
				verbosity>=10: debugging
			</info>
		</var>
		<var name="debug">
			<name> debug </name>
			<type> logical </type>
			<default> .false </default>
			<mandatory> no </mandatory>
			<info>
				For debug purpose.
			</info>
		</var>

		<!--[>Template for variable definition<]-->
		<!--<var name="">-->
			<!--<name>  </name>-->
			<!--<type>  </type>-->
			<!--<default>  </default>-->
			<!--<mandatory>  </mandatory>-->
			<!--<info>-->
			<!--</info>-->
			<!--<see_also> <ilink>  </ilink> </see_also>-->
		<!--</var>-->
	</namelist> 
</manual>
