<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="input_xx.xsl" type="text/xsl"?>
<manual>
	<title>
		Program displacement
	</title>
	<intro> 
		This program calculates atom displacements between 2 configurations
		an input and a reference structure files.
		The value of the total strain in the input structure can be calculated 
		on each atom by finite differences using this displacement field 
		and its variation in a neighbourhood sphere.

		The progam can also calculate elastic and plastic strain, Nye tensors,
	       	density of Burgers vector using the method described in:
			C. S. Hartley and Y. Mishin, Acta Mater. 53, 1313 (2005).
		Reference crystallographic patterns have to be defined 
		to associate each atom with one of these patterns.
		See variables: patternFile, patternAngleThreshold, patternSelectionMethod, rNeigh
	

		Execution:
		=========
		displacement input.dat
		where input.dat is the input file
		If input.dat="-", the input is read from current unit (keyboard or piped other command like echo)


		Structure of the input file:
		===========================

		The input file contains only the namelist input

		&amp;input
		  ...
		//

	</intro>
	<namelist name="input">
		<name> input </name>

		<var name="inpFile, refFile">
			<name>	inpFile, refFile </name>
			<type> character string </type>
			<default> '-' </default>
			<mandatory> yes </mandatory>
			<info>
				Name of the structure file used as input (strained) and reference.
				If inpFile='-' or refFile="-", the structure is read from keyboard.
				The file formats are defined by refXyz | refCfg | refGin | refSiesta | refNDM | refLammps | refPoscar
				and by inpXyz | inpCfg | inpGin | inpSiesta | inpNDM | inpLammps | inpPoscar

				Reference structure file is needed only if one wants to compute
				the total displacement or its gradient, or the total or plastic strain.
			</info>
			<see_also> <ilink>inpXyz, inpCfg, inpGin, inpSiesta, inpNDM, inpLammps, inpPoscar</ilink> </see_also>
			<see_also> <ilink>refXyz, refCfg, refGin, refSiesta, refNDM, refLammps, refPoscar</ilink> </see_also>
		</var>
		<var name="inpXyz, inpCfg, inpGin, inpSiesta, inpNDM, inpLammps, inpPoscar">
			<name>	inpXyz, inpCfg, inpGin, inpSiesta, inpNDM, inpLammps, inpPoscar  </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> one should be set to .true. </mandatory>
			<info>
				If inpXyz=.true. the input structure file 
				is given in xyz format.
			</info>
			<see_also> <elink> <text>Structure file formats</text> <url>./structures.html</url></elink> </see_also>
			<see_also> <ilink>inpFile, refFile</ilink> </see_also>
		</var>
		<var name="refXyz, refCfg, refGin, refSiesta, refNDM, refLammps, refPoscar">
			<name>	refXyz, refCfg, refGin, refSiesta, refNDM, refLammps, refPoscar  </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> one should be set to .true. </mandatory>
			<info>
				If refXyz=.true. the reference structure file 
				is given in xyz format.
			</info>
			<see_also> <elink> <text>Structure file formats</text> <url>./structures.html</url></elink> </see_also>
			<see_also> <ilink>inpFile, refFile</ilink> </see_also>
		</var>
		<var name="imm">
			<name>	imm </name>
			<type> integer </type>
			<default> 0 </default>
			<mandatory> no </mandatory>
			<info>
				Maximal number of atom in the structure.
				imm needs to be defined if the input structure is duplicated 
				to dimension the arrays. 
				Otherwise, the actual number of atoms, read from input structure file, is used.
			</info>
			<see_also> <ilink> duplicate </ilink> </see_also>
		</var>
		<var name="duplicate">
			<name> duplicate </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If duplicate=.true., the crystal is duplicated, both the input and reference strutures.
				lat(1:3) is the number of times the crystal should be duplicated
				in each direction given by the vectors at(1:3,i) read in the structure file.
				If lat(i) is negative, then the opposite of the vector at(1:3,i) is used.
				The maximal number of atoms in the duplicated structure needs to be set with imm
				and the periodicity vectors have to be defined.

				When the structure is also rotated, the duplication is done first and then the rotation.
				The periodicity vectors used for duplication are thus those before rotation.

				For small simulation boxes, it may be necessary to duplicate the structure 
				to find all neighbours of the atoms, when neighbours are needed
				(to extract Nye tensors or calculate strain for instance)
			</info>
			<see_also> <ilink> imm </ilink> </see_also>
			<see_also> <ilink> lat </ilink> </see_also>
		</var>
		<var name="lat">
			<name>	lat </name>
			<type> integer, dim(3) </type>
			<default> 1 </default>
			<mandatory> no  </mandatory>
			<info>
				Number of replicas in each direction when duplicating the structure files.
			</info>
			<see_also> <ilink> duplicate </ilink> </see_also>
		</var>
		<var name="rotate">
			<name> rotate </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If rotate=.true., the crystal is rotated using rotation matrix defined in rot(1:3,1:3)
				Both the input and reference structures are rotated.
			</info>
			<see_also> <ilink> rot </ilink> </see_also>
		</var>
		<var name="rot">
			<name> rot </name>
			<type> real, dim(3,3) </type>
			<default> identity matrix </default>
			<mandatory> no </mandatory>
			<info>
				Rotation matrix used when rotate=.true.
			</info>
			<see_also> <ilink> rotate </ilink> </see_also>
		</var>
		<var name="translate">
			<name> translate </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If translate=.true., the crystal is translated with the vector uTranslate(1:3)
				Both the input and reference structures are translated.
			</info>
			<see_also> <ilink> uTranslate </ilink> </see_also>
		</var>
		<var name="uTranslate">
			<name> uTranslate </name>
			<type> real, dim(3) </type>
			<default> 0. </default>
			<mandatory> no </mandatory>
			<info>
				Translation vector used when translate=.true.
				If alat is defined, uTranslate(1:3) is multiplied by alat.
			</info>
			<see_also> <ilink> translate </ilink> </see_also>
			<see_also> <ilink> alat </ilink> </see_also>
		</var>
		<var name="clipAtom">
			<name> clipAtom </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If clipAtom=.true., periodic boundary conditions are applied
			       	to atom coordinates to bring them back in the primitive unit cell.
				The periodicity vectors have to be defined.
				The transformation is applied both to the input and the reference structures.
			</info>
		</var>
		<var name="clipDisplacement">
			<name> clipDisplacement </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If clipDisplacement=.true., periodic boundary conditions are applied
				to atom displacements.
				The periodicity vectors have to be defined.
			</info>
		</var>
		<var name="alat">
			<name> alat </name>
			<type> real </type>
			<default> 1. </default>
			<mandatory> no </mandatory>
			<info>
				Length used to scale all distances in the present input file.
				For program displacement, it affects the quantities rNeigh and uTranslate(1:3).
			</info>
		</var>
		<var name="fixGravity">
			<name> fixGravity </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If fixGravity=.true., a solid displacement is added to atom positions
				in the input structure to keep fixed the gravity center compared 
				to the reference structure. 
				The same solid displacement is added to the calculated atom displacements. 
				As a consequence, the displacement average is null.
			</info>
		</var>
		<var name="patternFile">
			<name> patternFile </name>
			<type> character string </type>
			<default> empty </default>
			<mandatory> no </mandatory>
			<info>
				Name of the file where are stored the crystallographic patterns 
				defining the atom reference neighbourhoods.
				This is necessary to calculate elastic or plastic strains, 
				Nye tensors or Burgers density.
			        This file can then be generated with programs patternInit or patternDetect.
			</info>
			<see_also> <ilink> patternAngleThreshold </ilink> </see_also>
			<see_also> <ilink> patternSelectionMethod </ilink> </see_also>
		</var>
		<var name="patternAngleThreshold">
			<name> patternAngleThreshold </name>
			<type> real </type>
			<default> 10. </default>
			<mandatory> no </mandatory>
			<info>
				Threshold angle for pairing neighbour vectors when associating 
				each atom with a reference crystallographic pattern.
				Two bonds, in the atom neighbourhood of the input structure
				and in the reference crystallographic pattern, match 
				if the angle difference between the two corresponding directions 
				is smaller than this threshold.
			</info>
			<see_also> <ilink> patternFile </ilink> </see_also>
			<see_also> <ilink> patternSelectionMethod </ilink> </see_also>
		</var>
		<var name="patternSelectionMethod">
			<name> patternSelectionMethod </name>
			<type> integer </type>
			<default> 3 </default>
			<mandatory> no </mandatory>
			<info>
				Method used to associate a reference crystallographic pattern to each atom
				by comparing the atomic bonds of the corresponding neighbourhoods
				patternSelectionMethod
                                  = 1 : Select pattern which maximises the number of matchs 
                                        look to the NORM OF THE DISPLACEMENT if 2 patterns are equivalent
                                  = 2 : Select pattern which maximises the number of matchs 
                                        look to the norm of the ELASTIC GRADIENT if 2 patterns are equivalent
                                  = 3 : Select pattern which minimizes the number of unmatched bonds 
                                        look to the NORM OF THE DISPLACEMENT if 2 patterns are equivalent
                                  = 4 : Select pattern which minimizes the number of unmatched bonds 
                                        look to the norm of the ELASTIC GRADIENT if 2 patterns are equivalent
			</info>
			<see_also> <ilink> patternFile </ilink> </see_also>
			<see_also> <ilink> patternAngleThreshold </ilink> </see_also>
		</var>
		<var name="rNeigh">
			<name> rNeigh </name>
			<type> real </type>
			<default> -1. </default>
			<mandatory> yes </mandatory>
			<info>
				Distance cutoff defining the sphere where atom neighbours have to be looked for.
				If alat is defined, rNeigh is multiplied by alat.
			</info>
			<see_also> <ilink> alat </ilink> </see_also>
		</var>
		<var name="max_nNeigh">
			<name> max_nNeigh </name>
			<type> integer </type>
			<default> 16 </default>
			<mandatory> no </mandatory>
			<info>
				Maximal number of neighbours allowed for each atom.
			</info>
		</var>
		<var name="bNye">
			<name> bNye </name>
			<type> real, dim(3) </type>
			<default> 0. </default>
			<mandatory> no </mandatory>
			<info>
				Direction of the Burgers vector when projecting the Nye tensor 
				to define dislocation density.
			</info>
			<see_also> <ilink> lNye </ilink> </see_also>
		</var>
		<var name="lNye">
			<name> lNye </name>
			<type> real, dim(3) </type>
			<default> 0. </default>
			<mandatory> no </mandatory>
			<info>
				Direction of the dislocation lines when projecting the Nye tensor 
				to define dislocation density.
			</info>
			<see_also> <ilink> bNye </ilink> </see_also>
		</var>
		<var name="outFile">
			<name> outFile </name>
			<type> character string </type>
			<default> '-' </default>
			<mandatory> no </mandatory>
			<info>
				Name of the structure file where to save the input or the reference structure,
				depending of the value of variable 'initial',
				which auxiliary properties set for each atom (displacement, strain, dislocation density, ...)
				If outFile="-", the output file is printed on screen.
				The file format is defined by outXyz | outCfg  | outOnlyAtoms
			</info>
			<see_also> <ilink>outXyz, outCfg, outOnlyAtoms, outLammps, outPoscar</ilink> </see_also>
			<see_also> <ilink>initial</ilink> </see_also>
			<see_also> <ilink>out_alat</ilink> </see_also>
		</var>
		<var name="outXyz, outCfg, outOnlyAtoms, outLammps, outPoscar">
			<name> outXyz, outCfg, outOnlyAtoms, outLammps, outPoscar </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				Format of the structure file used for output.
				If all variables are set to .false. (default), the output structure
				is not written.
			</info>
			<see_also> <ilink> outFile </ilink> </see_also>
		</var>
		<var name="out_alat">
			<name> out_alat </name>
			<type> real </type>
			<default> 1. </default>
			<mandatory> no </mandatory>
			<info>
				When the output structure is written with xyz or cfg file format,
				atomic positions and periodicity vectors can be scaled by a lattice parameter
				given in out_alat.
			</info>
			<see_also> <ilink> outFile </ilink> </see_also>
			<see_also> <elink> <text>Structure file formats</text> <url>./structures.html</url></elink> </see_also>
		</var>
		<var name="initial">
			<name> initial </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If initial=.true. (.false.), the coordinates of the input (reference) structure
			       	are used on output.
			</info>
		</var>
		<var name="out_displacement">
			<name> out_displacement </name>
			<type> logical </type>
			<default> .true. </default>
			<mandatory> no </mandatory>
			<info>
				If out_displacement=.true., the displacement defined on each atom
				is printed in output structure file.
			</info>
		</var>
		<var name="out_gradDisplacement">
			<name> out_gradDisplacement </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_gradDisplacement=.true., the gradient of the displacement 
				defined on each atom is printed in output structure file.
				The gradient is obtained from atom displacements by finite differences.
				rNeigh needs to have been set to define atom neighbourhood used for finite differences.
			</info>
		</var>
		<var name="out_strain">
			<name> out_strain </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_strain=.true., the total strain defined on each atom
				is printed in output structure file.
				The total strain is obtained from the gradient of the total displacement
				using Green-Lagrange (default) or Euler-Lagrange definition.
			</info>
			<see_also> <ilink> out_gradDisplacement </ilink> </see_also>
			<see_also> <ilink> EulerLagrange </ilink> </see_also>
		</var>
		<var name="EulerLagrange">
			<name> EulerLagrange </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If EulerLagrange=.true., the Euler Lagrange definition is used 
				to obtain strain from displacement gradient.
				If EulerLagrange=.false., the Green Lagrange definition is used.
			</info>
			<see_also> <ilink> out_strain </ilink> </see_also>
			<see_also> <ilink> out_elasticStrain </ilink> </see_also>
		</var>
		<var name="out_gradElasticDisplacement">
			<name> out_gradElasticDisplacement </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_gradElasticDisplacement=.true., the gradient of the elastic displacement 
				defined on each atom is printed in output structure file.
				The gradient is obtained from atom displacements by finite differences,
				using only the elastic contribution to the displacement.
				Reference crystallographic patterns, read in file defined by patternFile,
				are used to calculate this elastic contribution.
				rNeigh needs to have been set to define atom neighbourhood used for finite differences.
			</info>
		</var>
		<var name="out_elasticStrain">
			<name> out_elasticStrain </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_elasticStrain=.true., the elastic strain defined on each atom
				is printed in output structure file.
				The elastic strain is obtained from the gradient of the elastic displacement
				using Green-Lagrange (default) or Euler-Lagrange definition.
			</info>
			<see_also> <ilink> out_gradDisplacement </ilink> </see_also>
			<see_also> <ilink> EulerLagrange </ilink> </see_also>
		</var>
		<var name="out_plasticStrain">
			<name> out_plasticStrain </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_plasticStrain=.true., the plastic strain defined on each atom
				is printed in output structure file.
				The plastic strain is obtained from the difference between
				the total and the elastic strains.
			</info>
			<see_also> <ilink> out_strain </ilink> </see_also>
			<see_also> <ilink> out_elasticStrain </ilink> </see_also>
		</var>
		<var name="out_nye">
			<name> out_nye </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_nye=.true., the Nye tensor defined on each atom 
				is printed in output structure file.
				The Nye tensor is obtained from the plastic strain 
				by finite differences.
			</info>
			<see_also> <ilink> out_plasticStrain </ilink> </see_also>
		</var>
		<var name="out_BurgersDensity">
			<name> out_BurgersDensity </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_burgersDensity=.true., the Burgers density defined on each atom 
				is printed in output structure file.
				The Burgers density is obtained by projection of the Nye tensor
				using lNye and bNye for the directions of the dislocation lines
				and of the Burgers vector.
			</info>
			<see_also> <ilink> out_nye </ilink> </see_also>
			<see_also> <ilink> bNye </ilink> </see_also>
			<see_also> <ilink> lNye </ilink> </see_also>
		</var>
		<var name="out_neighbours">
			<name> out_neighbours </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_neighbours=.true., the number of neighbours 
				is saved in output structure file for each atom.
			</info>
			<see_also> <ilink> outFile </ilink> </see_also>
		</var>
		<var name="out_pattern">
			<name> out_pattern </name>
			<type> logical </type>
			<default> .false. </default>
			<mandatory> no </mandatory>
			<info>
				If out_pattern=.true., the output pattern 
				is saved in output structure file for each atom.
			</info>
			<see_also> <ilink> outFile </ilink> </see_also>
		</var>
		<var name="verbosity">
			<name> verbosity </name>
			<type> integer </type>
			<default> 4 </default>
			<mandatory> no </mandatory>
			<info>
				Integer values defining amount of information on output unit.
				verbosity=0: no output
				verbosity=4: normal output
				verbosity>=10: debugging
			</info>
		</var>
		<var name="debug">
			<name> debug </name>
			<type> logical </type>
			<default> .false </default>
			<mandatory> no </mandatory>
			<info>
				For debug purpose.
			</info>
		</var>

		<!--[>Template for variable definition<]-->
		<!--<var name="">-->
			<!--<name>  </name>-->
			<!--<type>  </type>-->
			<!--<default>  </default>-->
			<!--<mandatory>  </mandatory>-->
			<!--<info>-->
			<!--</info>-->
			<!--<see_also>  </see_also>-->
		<!--</var>-->
	</namelist> 
</manual>
